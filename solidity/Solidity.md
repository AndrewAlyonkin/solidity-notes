Gas - наименьшая единица работы виртуальной машины Ethereum. За каждое действие смарт-контракта, включая его создание, 
нужно заплатить какое-то количество Gas. Gas нужно покупать, его стоимость постоянно меняется, но количество Gas,
которое нужно отдать за операции виртуальной машины - постоянно.  

Файлы смартконтрактов имеют наименования вида "Smartcontract.sol" - sol - расширение файла, наименование начинается 
с большой буквы.  

Пример простейшего смарт-контракта:  
// SPDX-License-Identifier: MIT  ``лицензия смартконтракта, которая говорит о том, что код контракта можно использовать,
но обязательно нужно указывать изначального автора.
Указывать лицензию не обязательно, но лучше указать во избежание предупреждений компилятора.`` 

    pragma solidity ^0.8.0; 
``версия языка, под которую нужно скомпилировать смарт-контракт. Язык очень быстро 
развивается и в разных версиях могут быть критические различия. Материалы, которые описывают работу с контрактами
ниже версии 0.6.0 - лучше пропускать.``

    contract Shop { 
``Имя смартконтракта. Начинается с большой буквы и пишется в CamelCase.``  
``Тело контракта. Для вложенности должно быть 4 пробела от начала строки.``

    address owner; 
``Адрес владельца контракта. Такая переменная является закрытой и ее нельзя считать извне.
для того, чтобы открыть доступ к ппеременной, нужно добавить ключевое слово "address public owner" - это позволит
только читать переменную извне, но ее невозможно будет изменить без создания специальной функции``

    mapping (address => uint) public payments;
``mapping - структура данных ключ-значение(мапа), в которой ключем является address, а значением uint - unsigned int
(целое число без знака). payments - наименование переменной.``

    constructor() {
``Конструктор контракта. Конструктор будет вызван автоматически сразу после того, как контракт будет помещен в блокчейн.
Конструктор вызывается автоматически и однократно, вызвать его повторно - невозможно``

    owner = msg.sender;
``Присвоение значения переменной владельца контракта. Значение берется из объекта msg. msg - то сообщение, из 
которого была выполнена транзакция с размещением контракта. Для каждого такого сообщение есть свойство sender - адрес
отправителя транзакции. Данные о owner = msg.sender сохраняются в блокчейн и хранятся там все время его существования``

    }

    function payForItem() public payable {
``function - ключевое слово, которое означает функцию. Для того, чтобы функцию можно было вызывать извне - используется
можификатор public. Модификатор payable указывает на то, что функция может принимать извне средства.
Если отправить средства в функцию, которая не помечена payable - средства вернутся отправителю и транзакция
завершится ошибкой.``  

``В теле функции можно ничего не указывать. Так как функция помечена payable - если вызвать эту функцию
и указать что нужно перевести какое-то количество средств - виртуальная машина Ethereum автоматически обработает
такую операцию и зачислит все средства на счет смартконтракта.``  

``Но можно и добавить дополнительную логику, например сохранить информацию об отправителе средств:``

    payments[msg.sender] = msg.value;
``msg.sender - адрес и сообщение того, кто вызвал функцию. msg.value - количество средств, с которыми функция
была вызвана, это количество средств будет зачислено на счет смартконтракта.  
payments[msg.sender] = msg.value - в мапу payments положить пару ключ=msg.sender, значение=msg.value. Таким образом
в мапе будут храниться адреса отправителей средств напротив суммы``

    }

    function withdrawAll() public {
``Функция перевода средств со счета смартконтракта на счет его владельца.  
Функция transfer() вызывается у того адреса, на который с текущего выполнится перевод. 
В данном случае невозможно выполнить owner.transfer() так как переменная owner не отмечена как payable.
Чтобы перевести на нее средства - мы создаем временную payable переменную _to, в которую с приведением присваиваем
payable(owner) - после этого мы можем совершить перевод.  
_to - временная переменная, что означает что она исчезнет после завершения функции (она будет храниться в памяти в
момент исполнения функции, а потом удалится). Невременные переменные навсегда сохраняются в блокчейне и за них нужно платить``

        address payable _to = payable(owner);

``Чтобы узнать баланс текущего контракта можно использовать ключевое слово this. this - позволяет контракту обратиться
к самому себе и с помощью address(this) получить свой адрес``

        address _thisContract = address(this);

``Чтобы получить информацию о балансе какого-либо счета - нужно на его адресе вызвать свойство balance.  
_thisContract.balance - получить информацию о количестве всех средств на текущем балансе и 
_to.transfer(_thisContract.balance) перевести все средства на счет owner``

        _to.transfer(_thisContract.balance);

        }
    }
