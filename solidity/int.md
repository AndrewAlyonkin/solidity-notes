Пока дробные числа не полностью поддерживаются в Solidity, возможно более полная их
поддержка появится в следующих версиях языка.  
  
**uint - unsigned int - целое число без знака.**
 
 `` Числа без знака знак не хранят, т.е. могут принимать значения от 0 до определенного предела.``  
 `` uint имеет свою размерность, которая указывает какое максимально допустимое число можно 
 сохранить в переменной.  
 При использовании uint всегда обязательно нужно указывать размерность. 
 Когда мы не указываем размерность - по умолчанию будет использоваться uint256.  
 256 - количество бит, которое выделяется для хранения числа. Таким образом, максимальное
 число, которое можно сохранить в такой переменной будет равняться 2^256. Если попытаться
 в переменную сохранить число, которое превышает размерность - будет ошибка.``  
  Допустимые размерности:  
 - uint8  (значения от 0 до 255)
 - uint16 (значения от 0 до (2^16)-1)
 - uint24  
 - uint32  
 - uint40  
 - uint48  
 - ..... с шагом 8  
 - uint256 - максимальная


**int - число со знаком.**  
``Хранят информацию о знаке числа. Для хранения информации о знаке из выделенной 
на число памяти всегда отдается один бит``  
  int public myInt = -42;  

Допустимые размерности:
- int8  (значения от -2^7 до (2^7)-1 =  от -128 до 127)
- int16 (значения от -2^15 до (2^15)-1)
- int24
- int32
- int40
- int48
- ..... с шагом 8
- int256 - максимальная

Допустимые операции с числами:

    contract DataTypes {
        uint public myUint = 42;

        function myFunc(uint _inputUint) {
            uint localUint = 50;
            localUint + _inputUint; - сложение
            localUint - _inputUint; - вычитание
            localUint * _inputUint; - умножение
            localUint / _inputUint; - деление. Результатом деления будет целое число, дробная часть отбросится
            localUint ** 3; - возведение в степень
            localUint % 3; - остаток от деления
            -localUint; - унарный минус
            
            операторы сравнения:
            localUint == _inputUint;
            localUint != _inputUint;
            localUint > _inputUint;
            localUint < _inputUint;
            localUint <= _inputUint;
            localUint >= _inputUint;

        }

    }

Получение минимального и максимального значения для типа данных:  

    contract Demo {
     uint public minimum;
     uint public maximum;

        function myFunc() {
            получить минимальное значение, которое допустимо для этого типа:
            minimum = type(uint8).min;

            получить максимальное значение, которое допустимо для этого типа:
            maximum = type(uint8).max;
        }

    }

Выход за допустимые пределы типа данных  

     contract Demo {
      uint8 public counter = 254; - значение переменной будет храниться в блокчейне

        Когда при очередном вызове функции значение переменной должно будет достигнуть 256 - 
        это превысит максимально допустимое значение 255 и виртуальная машина Ethereum выдаст
        ошибку и откатит такую транзакцию (и деньги вернулись бы обратно, если бы функция была payable).
        function increment() {
            // counter = counter + 1;
            // или counter += 1; или
            counter ++;
        }

      contract Demo {
           uint8 public counter = 254; - значение переменной будет храниться в блокчейне

        function increment() {

       Блок unchecked будет отлавливать ошибки переполнения, и когда значение переменной
       достигнет 256 - он сбросит переменную к минимальному значению, т.е в 0.  
       При этом он поглотит ошибку, которую выбросит виртуальная машина.
        unchecked {
            counter ++;
            }
        }

    }
